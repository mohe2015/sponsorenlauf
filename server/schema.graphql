### This file was generated by Nexus Schema
### Do not make changes to this file directly


type ClassRunners {
  class: String!
  runners: [Runner]!
}

type CreateRoundMutationError {
  startNumberError: String!
}

type CreateRoundMutationOutput {
  edge: RoundEdge!
}

union CreateRoundMutationResponse = CreateRoundMutationError | CreateRoundMutationOutput

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumUserRoleFieldUpdateOperationsInput {
  set: UserRole
}

input EnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type LoginMutationError {
  passwordError: String
  usernameError: String
}

union LoginMutationResponse = LoginMutationError | User

type Mutation {
  _hidden_deelteOneRound(where: RoundWhereUniqueInput!): Round
  _hidden_we_need_the_types_createOneRound(data: RoundCreateInput!): Round!
  _hidden_we_need_the_types_createOneRunner(data: RunnerCreateInput!): Runner!
  _hidden_we_need_the_types_createOneUser(data: UserCreateInput!): User!
  _hidden_we_need_the_types_updateOneRound(data: RoundUpdateInput!, where: RoundWhereUniqueInput!): Round
  _hidden_we_need_the_types_updateOneRunner(data: RunnerUpdateInput!, where: RunnerWhereUniqueInput!): Runner
  _hidden_we_need_the_types_updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  createOneRound(data: RoundCreateInput!): CreateRoundMutationResponse!
  createOneRunner(data: RunnerCreateInput!): RunnerMutationResponse!
  createOneUser(data: UserCreateInput!): UserMutationResponse!
  deleteOneRound(where: RoundWhereUniqueInput!): Round
  deleteOneRunner(where: RunnerWhereUniqueInput!): Runner
  deleteOneUser(where: UserWhereUniqueInput!): User
  generatePasswords: QueryUsers_Connection!
  login(name: String!, password: String!): LoginMutationResponse!
  logout: Boolean!
  updateOneRunner(data: RunnerUpdateInput!, where: RunnerWhereUniqueInput!): RunnerMutationResponse!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): UserMutationResponse!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

interface Node {
  """CUID for a resource"""
  id: String!
}

"""
PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  The cursor corresponding to the last nodes in edges. Null if the connection is empty.
  """
  endCursor: String

  """
  Used to indicate whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Used to indicate whether more edges exist prior to the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """
  The cursor corresponding to the first nodes in edges. Null if the connection is empty.
  """
  startCursor: String
}

type Query {
  _hidden_rounds(after: RoundWhereUniqueInput, before: RoundWhereUniqueInput, first: Int!, last: Int!, where: RoundWhereInput): [Round!]!
  _hidden_runners(after: RunnerWhereUniqueInput, before: RunnerWhereUniqueInput, first: Int!, last: Int!, orderBy: [RunnerOrderByInput!], where: RunnerWhereInput): [Runner!]!
  me: User!
  node(id: ID!): Node!
  rounds(
    """Returns the elements in the list that come after the specified cursor"""
    after: String
    filter: RoundWhereInput

    """Returns the first n elements from the list."""
    first: Int!
    orderBy: RoundOrderByInput!
  ): RoundConnection!
  runner(where: RunnerWhereUniqueInput!): Runner
  runners(
    """Returns the elements in the list that come after the specified cursor"""
    after: String

    """Returns the first n elements from the list."""
    first: Int!
    orderBy: RunnerOrderByInput!
  ): QueryRunners_Connection!
  runnersByClass: [ClassRunners]!
  user(where: UserWhereUniqueInput!): User
  users(
    """Returns the elements in the list that come after the specified cursor"""
    after: String

    """Returns the first n elements from the list."""
    first: Int!
  ): QueryUsers_Connection!
}

enum QueryMode {
  default
  insensitive
}

type QueryRunners_Connection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [RunnerEdge]

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  totalCount: Int!
}

type QueryUsers_Connection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [UserEdge]

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
  totalCount: Int!
}

type Round {
  createdBy: User!
  id: String!
  student: Runner!
  time: DateTime!
}

type RoundConnection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [RoundEdge]

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

input RoundCreateInput {
  id: String
  student: RunnerCreateOneWithoutRoundsInput!
  time: DateTime
}

input RoundCreateManyWithoutCreatedByInput {
  connect: [RoundWhereUniqueInput!]
  connectOrCreate: [RoundCreateOrConnectWithoutUserInput!]
  create: [RoundCreateWithoutCreatedByInput!]
}

input RoundCreateManyWithoutStudentInput {
  connect: [RoundWhereUniqueInput!]
  connectOrCreate: [RoundCreateOrConnectWithoutRunnerInput!]
  create: [RoundCreateWithoutStudentInput!]
}

input RoundCreateOrConnectWithoutRunnerInput {
  create: RoundCreateWithoutStudentInput!
  where: RoundWhereUniqueInput!
}

input RoundCreateOrConnectWithoutUserInput {
  create: RoundCreateWithoutCreatedByInput!
  where: RoundWhereUniqueInput!
}

input RoundCreateWithoutCreatedByInput {
  id: String
  student: RunnerCreateOneWithoutRoundsInput!
  time: DateTime
}

input RoundCreateWithoutStudentInput {
  createdBy: UserCreateOneWithoutCreatedRoundsInput!
  id: String
  time: DateTime
}

type RoundEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: Round!
}

input RoundListRelationFilter {
  every: RoundWhereInput
  none: RoundWhereInput
  some: RoundWhereInput
}

input RoundOrderByInput {
  createdById: SortOrder
  id: SortOrder
  studentId: SortOrder
  time: SortOrder
}

input RoundScalarWhereInput {
  AND: [RoundScalarWhereInput!]
  createdById: StringFilter
  id: StringFilter
  NOT: [RoundScalarWhereInput!]
  OR: [RoundScalarWhereInput!]
  studentId: StringFilter
  time: DateTimeFilter
}

input RoundUpdateInput {
  createdBy: UserUpdateOneRequiredWithoutCreatedRoundsInput
  id: StringFieldUpdateOperationsInput
  student: RunnerUpdateOneRequiredWithoutRoundsInput
  time: DateTimeFieldUpdateOperationsInput
}

input RoundUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  time: DateTimeFieldUpdateOperationsInput
}

input RoundUpdateManyWithoutCreatedByInput {
  connect: [RoundWhereUniqueInput!]
  connectOrCreate: [RoundCreateOrConnectWithoutUserInput!]
  create: [RoundCreateWithoutCreatedByInput!]
  delete: [RoundWhereUniqueInput!]
  deleteMany: [RoundScalarWhereInput!]
  disconnect: [RoundWhereUniqueInput!]
  set: [RoundWhereUniqueInput!]
  update: [RoundUpdateWithWhereUniqueWithoutCreatedByInput!]
  updateMany: [RoundUpdateManyWithWhereNestedInput!]
  upsert: [RoundUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input RoundUpdateManyWithoutStudentInput {
  connect: [RoundWhereUniqueInput!]
  connectOrCreate: [RoundCreateOrConnectWithoutRunnerInput!]
  create: [RoundCreateWithoutStudentInput!]
  delete: [RoundWhereUniqueInput!]
  deleteMany: [RoundScalarWhereInput!]
  disconnect: [RoundWhereUniqueInput!]
  set: [RoundWhereUniqueInput!]
  update: [RoundUpdateWithWhereUniqueWithoutStudentInput!]
  updateMany: [RoundUpdateManyWithWhereNestedInput!]
  upsert: [RoundUpsertWithWhereUniqueWithoutStudentInput!]
}

input RoundUpdateManyWithWhereNestedInput {
  data: RoundUpdateManyDataInput!
  where: RoundScalarWhereInput!
}

input RoundUpdateWithoutCreatedByDataInput {
  id: StringFieldUpdateOperationsInput
  student: RunnerUpdateOneRequiredWithoutRoundsInput
  time: DateTimeFieldUpdateOperationsInput
}

input RoundUpdateWithoutStudentDataInput {
  createdBy: UserUpdateOneRequiredWithoutCreatedRoundsInput
  id: StringFieldUpdateOperationsInput
  time: DateTimeFieldUpdateOperationsInput
}

input RoundUpdateWithWhereUniqueWithoutCreatedByInput {
  data: RoundUpdateWithoutCreatedByDataInput!
  where: RoundWhereUniqueInput!
}

input RoundUpdateWithWhereUniqueWithoutStudentInput {
  data: RoundUpdateWithoutStudentDataInput!
  where: RoundWhereUniqueInput!
}

input RoundUpsertWithWhereUniqueWithoutCreatedByInput {
  create: RoundCreateWithoutCreatedByInput!
  update: RoundUpdateWithoutCreatedByDataInput!
  where: RoundWhereUniqueInput!
}

input RoundUpsertWithWhereUniqueWithoutStudentInput {
  create: RoundCreateWithoutStudentInput!
  update: RoundUpdateWithoutStudentDataInput!
  where: RoundWhereUniqueInput!
}

input RoundWhereInput {
  AND: [RoundWhereInput!]
  createdBy: UserWhereInput
  createdById: StringFilter
  id: StringFilter
  NOT: [RoundWhereInput!]
  OR: [RoundWhereInput!]
  student: RunnerWhereInput
  studentId: StringFilter
  time: DateTimeFilter
}

input RoundWhereUniqueInput {
  id: String
}

type Runner implements Node {
  clazz: String!
  grade: Int!
  id: String!
  name: String!
  roundCount: Int!
  rounds(after: RoundWhereUniqueInput, before: RoundWhereUniqueInput, first: Int!, last: Int!, orderBy: [RoundOrderByInput!]): [Round!]!
  startNumber: Int!
}

input RunnerCreateInput {
  clazz: String!
  grade: Int!
  id: String
  name: String!
  roundCount: Int
  rounds: RoundCreateManyWithoutStudentInput
  startNumber: Int
}

input RunnerCreateOneWithoutRoundsInput {
  connect: RunnerWhereUniqueInput
  connectOrCreate: RunnerCreateOrConnectWithoutRoundInput
  create: RunnerCreateWithoutRoundsInput
}

input RunnerCreateOrConnectWithoutRoundInput {
  create: RunnerCreateWithoutRoundsInput!
  where: RunnerWhereUniqueInput!
}

input RunnerCreateWithoutRoundsInput {
  clazz: String!
  grade: Int!
  id: String
  name: String!
  roundCount: Int
  startNumber: Int
}

type RunnerEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: Runner!
}

type RunnerMutationError {
  gradeError: String
  nameError: String!
}

type RunnerMutationOutput {
  edge: RunnerEdge!
}

union RunnerMutationResponse = RunnerMutationError | RunnerMutationOutput

input RunnerOrderByInput {
  clazz: SortOrder
  grade: SortOrder
  id: SortOrder
  name: SortOrder
  roundCount: SortOrder
  startNumber: SortOrder
}

input RunnerUpdateInput {
  clazz: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  roundCount: IntFieldUpdateOperationsInput
  rounds: RoundUpdateManyWithoutStudentInput
}

input RunnerUpdateOneRequiredWithoutRoundsInput {
  connect: RunnerWhereUniqueInput
  connectOrCreate: RunnerCreateOrConnectWithoutRoundInput
  create: RunnerCreateWithoutRoundsInput
  update: RunnerUpdateWithoutRoundsDataInput
  upsert: RunnerUpsertWithoutRoundsInput
}

input RunnerUpdateWithoutRoundsDataInput {
  clazz: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  roundCount: IntFieldUpdateOperationsInput
}

input RunnerUpsertWithoutRoundsInput {
  create: RunnerCreateWithoutRoundsInput!
  update: RunnerUpdateWithoutRoundsDataInput!
}

input RunnerWhereInput {
  AND: [RunnerWhereInput!]
  clazz: StringFilter
  grade: IntFilter
  id: StringFilter
  name: StringFilter
  NOT: [RunnerWhereInput!]
  OR: [RunnerWhereInput!]
  roundCount: IntFilter
  rounds: RoundListRelationFilter
  startNumber: IntFilter
}

input RunnerWhereUniqueInput {
  id: String
  name: String
  startNumber: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  subscribeRounds: CreateRoundMutationOutput!
  subscribeUsers: UserMutationOutput!
}

type User {
  createdRounds(after: RoundWhereUniqueInput, before: RoundWhereUniqueInput, first: Int!, last: Int!): [Round!]!
  id: String!
  name: String!
  password: String!
  role: UserRole!
}

input UserCreateInput {
  createdRounds: RoundCreateManyWithoutCreatedByInput
  currentSessions: UserSessionCreateManyWithoutUserInput
  id: String
  name: String!
  role: UserRole!
}

input UserCreateOneWithoutCreatedRoundsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoundInput
  create: UserCreateWithoutCreatedRoundsInput
}

input UserCreateOrConnectWithoutRoundInput {
  create: UserCreateWithoutCreatedRoundsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCreatedRoundsInput {
  currentSessions: UserSessionCreateManyWithoutUserInput
  id: String
  name: String!
  password: String!
  role: UserRole!
}

type UserEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: User!
}

type UserMutationError {
  roleError: String
  usernameError: String!
}

type UserMutationOutput {
  edge: UserEdge!
}

union UserMutationResponse = UserMutationError | UserMutationOutput

"""The users role"""
enum UserRole {
  ADMIN
  TEACHER
  VIEWER
}

input UserSessionCreateManyWithoutUserInput {
  connect: [UserSessionWhereUniqueInput!]
  connectOrCreate: [UserSessionCreateOrConnectWithoutUserInput!]
  create: [UserSessionCreateWithoutUserInput!]
}

input UserSessionCreateOrConnectWithoutUserInput {
  create: UserSessionCreateWithoutUserInput!
  where: UserSessionWhereUniqueInput!
}

input UserSessionCreateWithoutUserInput {
  id: String!
  validUntil: DateTime!
}

input UserSessionListRelationFilter {
  every: UserSessionWhereInput
  none: UserSessionWhereInput
  some: UserSessionWhereInput
}

input UserSessionScalarWhereInput {
  AND: [UserSessionScalarWhereInput!]
  id: StringFilter
  NOT: [UserSessionScalarWhereInput!]
  OR: [UserSessionScalarWhereInput!]
  userId: StringFilter
  validUntil: DateTimeFilter
}

input UserSessionUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  validUntil: DateTimeFieldUpdateOperationsInput
}

input UserSessionUpdateManyWithoutUserInput {
  connect: [UserSessionWhereUniqueInput!]
  connectOrCreate: [UserSessionCreateOrConnectWithoutUserInput!]
  create: [UserSessionCreateWithoutUserInput!]
  delete: [UserSessionWhereUniqueInput!]
  deleteMany: [UserSessionScalarWhereInput!]
  disconnect: [UserSessionWhereUniqueInput!]
  set: [UserSessionWhereUniqueInput!]
  update: [UserSessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserSessionUpdateManyWithWhereNestedInput!]
  upsert: [UserSessionUpsertWithWhereUniqueWithoutUserInput!]
}

input UserSessionUpdateManyWithWhereNestedInput {
  data: UserSessionUpdateManyDataInput!
  where: UserSessionScalarWhereInput!
}

input UserSessionUpdateWithoutUserDataInput {
  id: StringFieldUpdateOperationsInput
  validUntil: DateTimeFieldUpdateOperationsInput
}

input UserSessionUpdateWithWhereUniqueWithoutUserInput {
  data: UserSessionUpdateWithoutUserDataInput!
  where: UserSessionWhereUniqueInput!
}

input UserSessionUpsertWithWhereUniqueWithoutUserInput {
  create: UserSessionCreateWithoutUserInput!
  update: UserSessionUpdateWithoutUserDataInput!
  where: UserSessionWhereUniqueInput!
}

input UserSessionWhereInput {
  AND: [UserSessionWhereInput!]
  id: StringFilter
  NOT: [UserSessionWhereInput!]
  OR: [UserSessionWhereInput!]
  user: UserWhereInput
  userId: StringFilter
  validUntil: DateTimeFilter
}

input UserSessionWhereUniqueInput {
  id: String
}

input UserUpdateInput {
  createdRounds: RoundUpdateManyWithoutCreatedByInput
  currentSessions: UserSessionUpdateManyWithoutUserInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCreatedRoundsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoundInput
  create: UserCreateWithoutCreatedRoundsInput
  update: UserUpdateWithoutCreatedRoundsDataInput
  upsert: UserUpsertWithoutCreatedRoundsInput
}

input UserUpdateWithoutCreatedRoundsDataInput {
  currentSessions: UserSessionUpdateManyWithoutUserInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
}

input UserUpsertWithoutCreatedRoundsInput {
  create: UserCreateWithoutCreatedRoundsInput!
  update: UserUpdateWithoutCreatedRoundsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdRounds: RoundListRelationFilter
  currentSessions: UserSessionListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  role: EnumUserRoleFilter
}

input UserWhereUniqueInput {
  id: String
  name: String
}
